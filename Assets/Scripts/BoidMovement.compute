#pragma kernel cs_main

#define MAX_INDEX_STORE_IN_SPATIAL 100
#pragma target 4.5

#include <UnityShaderVariables.cginc>

// Some constant data from C# side
float left_bound;
float right_bound;
float top_bound;
float bottom_bound;
int boid_count;
float boid_speed;
float deltaTime;

float alignment_weight;
float separation_weight;
float cohesion_weight;

float boid_radius;

struct boid_data
{
    float2 position;
    float rotationInRad; // in degrees
};

struct spatial_data
{
    int startIndex;
    int count;

    uint containIndices[MAX_INDEX_STORE_IN_SPATIAL];
};

RWStructuredBuffer<boid_data> data;
RWStructuredBuffer<spatial_data> spatialData;

void get_spatial_data_index(const float2 position,inout int index)
{
    const int col = floor((position.x - left_bound) / boid_radius);
    const int row = floor((position.y - bottom_bound) / boid_radius);
    index = row * ceil((right_bound - left_bound) / boid_radius) + col;
}

// implement boid algorithm and find the next direction
void calculate_next_direction(const float2 thisBoidPosition,inout float2 dir)
{
    float2 accumulateDirectionToOtherBoids = float2(0, 0); // for Separation
    float2 accumulateForwardDirectionOfOtherBoids = float2(0, 0); // for Alignment
    float2 averagePositionOfOtherBoids = float2(0, 0); // for Cohesion

    int numberOfInRangeBoid = 0;

    for (int row = -1;row <= 1;row++)
    {
        for (int col = -1;col <= 1;col++)
        {
            float2 check_position = thisBoidPosition + float2(col, row) * boid_radius;
            if(check_position.x < left_bound || check_position.x > right_bound || check_position.y < bottom_bound || check_position.y > top_bound)
            {
                continue;
            }

            int spatial_index = -1;
            get_spatial_data_index(check_position, spatial_index);

            if(spatial_index == -1)
            {
                return;
            }

            spatial_data spatial = spatialData[spatial_index];
            for(int i = 0; i< spatial.count;i++)
            {
                int correct_index = (i + spatial.startIndex)% uint(MAX_INDEX_STORE_IN_SPATIAL);
                int other_boid_index = spatial.containIndices[correct_index];

                boid_data other_boid_data = data[other_boid_index];
                float2 otherBoidPosition = other_boid_data.position;

                const float2 delta = thisBoidPosition - otherBoidPosition;
                const float distanceSquared = dot(delta, delta);
                const float radiusSquared = boid_radius * boid_radius;

                if (distanceSquared > radiusSquared)
                {
                    continue;
                }

                float2 other_dir = float2(sin(other_boid_data.rotationInRad), cos(other_boid_data.rotationInRad));
                other_dir = normalize(other_dir);

                accumulateDirectionToOtherBoids += thisBoidPosition - otherBoidPosition; // Subtract to move away
                accumulateForwardDirectionOfOtherBoids += other_dir;
                averagePositionOfOtherBoids += otherBoidPosition;
                numberOfInRangeBoid++;
            }
        }
    }
    
    if(numberOfInRangeBoid > 0)
    {
        // Cohesion: Calculate the average position and the direction to that position
        float2 centerOfMass = averagePositionOfOtherBoids / numberOfInRangeBoid;
        float2 cohesionDirection = normalize(centerOfMass - thisBoidPosition) * cohesion_weight;

        // Separation: Move away from the neighbors
        float2 separationDirection = normalize(accumulateDirectionToOtherBoids / numberOfInRangeBoid) * separation_weight;

        // Alignment: Steer towards the average heading of neighbors
        float2 alignmentDirection = normalize(accumulateForwardDirectionOfOtherBoids / numberOfInRangeBoid) * alignment_weight;

        // Combine the three steering behaviors
        dir += cohesionDirection + separationDirection + alignmentDirection;
    }

    dir = normalize(dir);
}

[numthreads(128, 1, 1)]
void cs_main(uint3 id : SV_DispatchThreadID)
{
    boid_data boid_instance_data = data[id.x];
    
    // Convert the rotation from degrees to radians
    // Calculate the direction vector: x = cos(rad), y = sin(rad)
    float2 dir = float2(sin(boid_instance_data.rotationInRad), cos(boid_instance_data.rotationInRad));
    dir = normalize(dir);
    
    calculate_next_direction(boid_instance_data.position, dir);
    
    // move the boid to target position based on the direction vector
    float2 new_pos = boid_instance_data.position + dir * (boid_speed * deltaTime);
    if(new_pos.x < left_bound)
    {
        new_pos.x = right_bound;
    }
    if(new_pos.x > right_bound)
    {
        new_pos.x = left_bound;
    }
    if(new_pos.y < bottom_bound)
    {
        new_pos.y = top_bound;
    }
    if(new_pos.y > top_bound)
    {
        new_pos.y = bottom_bound;
    }
    
    // Update the position and rotationInRad back to the original data
    boid_instance_data.position = new_pos;
    boid_instance_data.rotationInRad =  atan2(dir.x, dir.y);
    
    // Write the updated boid data back to the buffer
    data[id.x] = boid_instance_data;
}

