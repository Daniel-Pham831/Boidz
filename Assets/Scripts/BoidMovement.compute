#pragma kernel cs_main
#include <UnityShaderVariables.cginc>

// Some constant data from C# side
float left_bound;
float right_bound;
float top_bound;
float bottom_bound;
int boid_count;
float boid_speed;
float deltaTime;

float alignment_weight;
float separation_weight;
float cohesion_weight;

float boid_radius;
struct boid_data
{
    float2 position;
    float2 dir;
};

RWStructuredBuffer<boid_data> data;

// implement boid algorithm and find the next direction
void calculate_next_direction(const int id,const float2 thisBoidPosition,inout float2 dir)
{
    float2 accumulateDirectionToOtherBoids = float2(0, 0); // for Separation
    float2 accumulateForwardDirectionOfOtherBoids = float2(0, 0); // for Alignment
    float2 averagePositionOfOtherBoids = float2(0, 0); // for Cohesion

    int numberOfInRangeBoid = 0;
    const float radiusSquared = boid_radius * boid_radius;
    
    for (int i = 0; i < boid_count;i++)
    {
        if(id == i)
        {
            continue;
        }

        boid_data other_boid_data = data[i];
        float2 otherBoidPosition = other_boid_data.position;
        float distanceSquared = dot(thisBoidPosition - otherBoidPosition, thisBoidPosition - otherBoidPosition);
        if (distanceSquared > radiusSquared)
        {
            continue;
        }


        float2 other_dir = other_boid_data.dir;
        accumulateDirectionToOtherBoids += thisBoidPosition - otherBoidPosition; // Subtract to move away
        accumulateForwardDirectionOfOtherBoids += other_dir;
        averagePositionOfOtherBoids += otherBoidPosition;
        numberOfInRangeBoid++;
    }

    if(numberOfInRangeBoid > 0)
    {
        // Cohesion: Calculate the average position and the direction to that position
        float2 centerOfMass = averagePositionOfOtherBoids / numberOfInRangeBoid;
        float2 cohesionDirection = normalize(centerOfMass - thisBoidPosition) * cohesion_weight;

        // Separation: Move away from the neighbors
        float2 separationDirection = normalize(accumulateDirectionToOtherBoids / numberOfInRangeBoid) * separation_weight;

        // Alignment: Steer towards the average heading of neighbors
        float2 alignmentDirection = normalize(accumulateForwardDirectionOfOtherBoids / numberOfInRangeBoid) * alignment_weight;

        // Combine the three steering behaviors
        dir += cohesionDirection + separationDirection + alignmentDirection;
    }

    dir = normalize(dir);
}

[numthreads(1024, 1, 1)]
void cs_main(uint3 id : SV_DispatchThreadID)
{
    boid_data boid_instance_data = data[id.x];

    // Convert the rotation from degrees to radians
    // Calculate the direction vector: x = cos(rad), y = sin(rad)
    float2 dir = boid_instance_data.dir;
    dir = normalize(dir);

    calculate_next_direction(id.x, boid_instance_data.position, dir);
    
    // move the boid to target position based on the direction vector
    float2 new_pos = boid_instance_data.position + dir * (boid_speed * deltaTime);
    if(new_pos.x < left_bound)
    {
        new_pos.x = right_bound;
    }
    if(new_pos.x > right_bound)
    {
        new_pos.x = left_bound;
    }
    if(new_pos.y < bottom_bound)
    {
        new_pos.y = top_bound;
    }
    if(new_pos.y > top_bound)
    {
        new_pos.y = bottom_bound;
    }

    // Update the position and rotationInRad back to the original data
    boid_instance_data.position = new_pos;
    boid_instance_data.dir =  dir;

    // Write the updated boid data back to the buffer
    data[id.x] = boid_instance_data;
}

